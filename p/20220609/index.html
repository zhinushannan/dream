<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>进程与线程 | 梦想已故</title><meta name="keywords" content="操作系统,进程,线程"><meta name="author" content="zhinushannan"><meta name="copyright" content="zhinushannan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统上一篇：操作系统概述操作系统下一篇：进程同步与通信 进程的引入进程与程序进程是可并发执行的程序在一个数据集合上的执行过程。 程序是一个按顺序设计的计算机指令的集合，而进程就是执行这个指令集合的过程。程序是一个存放在计算机存储空间内的静态文件。 单道程序的顺序执行程序的顺序执行  顺序执行中，每个程序的执行顺序是严格按照次序先后关系进行的。例如：  在单道环境中，程序段的执行也是严格按照顺序">
<meta property="og:type" content="article">
<meta property="og:title" content="进程与线程">
<meta property="og:url" content="https://dream.kwcoder.club/p/20220609/index.html">
<meta property="og:site_name" content="梦想已故">
<meta property="og:description" content="操作系统上一篇：操作系统概述操作系统下一篇：进程同步与通信 进程的引入进程与程序进程是可并发执行的程序在一个数据集合上的执行过程。 程序是一个按顺序设计的计算机指令的集合，而进程就是执行这个指令集合的过程。程序是一个存放在计算机存储空间内的静态文件。 单道程序的顺序执行程序的顺序执行  顺序执行中，每个程序的执行顺序是严格按照次序先后关系进行的。例如：  在单道环境中，程序段的执行也是严格按照顺序">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dream.kwcoder.club/images/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1.cover.png">
<meta property="article:published_time" content="2022-06-09T00:29:07.000Z">
<meta property="article:modified_time" content="2022-06-13T07:11:43.979Z">
<meta property="article:author" content="zhinushannan">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="进程">
<meta property="article:tag" content="线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dream.kwcoder.club/images/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1.cover.png"><link rel="shortcut icon" href="/images/icon.png"><link rel="canonical" href="https://dream.kwcoder.club/p/20220609/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://jsdelivr.kwcoder.club/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://jsdelivr.kwcoder.club/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://jsdelivr.kwcoder.club/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://jsdelivr.kwcoder.club/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '进程与线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-13 15:11:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_3367359_iv6omb2moap.css" ><link rel="stylesheet" href="/css/cavedraw.css" ><script src="https://jsdelivr.kwcoder.club/gh/flatblowfish/cave-draw/dist/cave-draw.min.js"></script><script src="/npm/valine/dist/Valine.min.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avator.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1.cover.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">梦想已故</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">进程与线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-06-09T00:29:07.000Z" title="发表于 2022-06-09 08:29:07">2022-06-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>操作系统上一篇：<a href="/p/20220513/" target="_blank">操作系统概述</a><br>操作系统下一篇：进程同步与通信</p>
<h1 id="进程的引入"><a href="#进程的引入" class="headerlink" title="进程的引入"></a>进程的引入</h1><h2 id="进程与程序"><a href="#进程与程序" class="headerlink" title="进程与程序"></a>进程与程序</h2><p>进程是<strong>可并发执行的程序</strong>在一个<strong>数据集合</strong>上的执行过程。</p>
<p>程序是一个按顺序设计的计算机指令的集合，而进程就是执行这个指令集合的过程。<strong>程序是一个存放在计算机存储空间内的静态文件</strong>。</p>
<h2 id="单道程序的顺序执行"><a href="#单道程序的顺序执行" class="headerlink" title="单道程序的顺序执行"></a>单道程序的顺序执行</h2><h3 id="程序的顺序执行"><a href="#程序的顺序执行" class="headerlink" title="程序的顺序执行"></a>程序的顺序执行</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/操作系统/3进程与线程/1.顺序执行时操作的先后次序.png" style="zoom: 50%;">

<p>顺序执行中，每个程序的执行顺序是严格按照次序先后关系进行的。例如：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2.%E7%A8%8B%E5%BA%8F%E6%AE%B5%E7%9A%84%E6%89%A7%E8%A1%8C.png" alt="程序段的执行.png"></p>
<p>在单道环境中，程序段的执行也是严格按照顺序执行的。</p>
<h3 id="顺序执行的特征"><a href="#顺序执行的特征" class="headerlink" title="顺序执行的特征"></a>顺序执行的特征</h3><ol>
<li>顺序性：程序在执行时，严格按照规定的顺序执行。</li>
<li>封闭性：程序是在封闭的环境中执行的，程序在执行时独占系统中的全部资源。</li>
<li>可再现性：当程序被重复执行时，只要初始条件相同，其执行结果必然相同。</li>
</ol>
<p>应用：这些特征给测试和修改程序带来了很大的方便（debug）。</p>
<h2 id="多道程序的并发执行"><a href="#多道程序的并发执行" class="headerlink" title="多道程序的并发执行"></a>多道程序的并发执行</h2><p>单道程序系统浪费资源、效率低下，现代操作系统几乎不采用，而广泛采用多道程序设计技术。多道程序设计是在内存中存放多道程序，他们在操作系统的控制下在CPU上交替执行。</p>
<h3 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h3><p>为了提高计算机内各种资源的利用率，提高计算机系统的处理能力，并发处理技术得到广泛的应用。<br>而有些计算是允许并发执行的，有些操作是需要顺序执行的。<br>例如，下面两张图中，第一张图的计算是必须按照顺序执行的，而第二张图可以并发执行：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2.%E7%A8%8B%E5%BA%8F%E6%AE%B5%E7%9A%84%E6%89%A7%E8%A1%8C.png" alt="程序段的执行.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/3.%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%AE%B5.png" alt="并发执行的程序段.png"></p>
<h3 id="并发执行的条件-——-Bernstein"><a href="#并发执行的条件-——-Bernstein" class="headerlink" title="并发执行的条件 —— Bernstein"></a>并发执行的条件 —— Bernstein</h3><p>对于两个进程P1、P2，记P1的读集、写集分别为R(P1)、W(P1)，P2的读集、写集为R(P2)、R(P2)，若满足：<code>R(P1)∩W(P2)∪R(P2)∩W(P1)∪W(P1)∩W(P2)=&#123;&#125;</code>，则P1、P2可以并发执行且具有再现性。</p>
<p>范例:<br>对于：<br>P1：    a&#x3D;5<br>P2：    b&#x3D;6<br>P3：    c&#x3D;a+b<br>P4：    d&#x3D;c+1</p>
<p>的执行图如下：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  graph LR
P1 --&gt; P3
p2 --&gt; P3
P3 --&gt; P4
  </pre></div>

<blockquote>
<p>P1:  a&#x3D;5<br>P2:	  b&#x3D;6<br>R(P1)&#x3D;{} W(P1)&#x3D;{a}<br>R(P2)&#x3D;{} W(P2)&#x3D;{b}<br>R(P1) ∩W(P2)&#x3D;{} R(P2) ∩W(P1)&#x3D;{}<br>W(P1) ∩W(P2)&#x3D;{}<br>R(P1)∩W(P2)∪R(P2)∩W(P1)∪W(P1)∩W(P2)&#x3D;{}<br>P1、P2可以并发执行</p>
</blockquote>
<blockquote>
<p>P3:	c&#x3D;a+b<br>P4:		d&#x3D;c+1<br>R(P3)&#x3D;{a,b} W(P3)&#x3D;{c}<br>R(P4)&#x3D;{c} W(P4)&#x3D;{d}<br>R(P3) ∩ W(P4)&#x3D;{}<br>R(P4) ∩ W(P3)&#x3D;{c}<br>R(P3) ∩ W(P4) ∪ R(P4) ∩ W(P3) ∪ W(P3) ∩ W(P4) &#x3D;{c}<br>P3、P4不能并发执行</p>
</blockquote>
<h3 id="程序并发执行的特征"><a href="#程序并发执行的特征" class="headerlink" title="程序并发执行的特征"></a>程序并发执行的特征</h3><ol>
<li>间断性：进程之间需要相互配合，有时需要暂停等待另一个进程执行完毕才可以继续执行。</li>
<li>失去封闭性：多个程序共享系统的各种资源，这些资源的状态由多个程序改变，致使其失去封闭性。</li>
<li>失去可再现性：由于失去了封闭性，系统的资源状态的变化是不可预测的，因而也失去了可再现性。</li>
</ol>
<h3 id="进程与程序的对应关系"><a href="#进程与程序的对应关系" class="headerlink" title="进程与程序的对应关系"></a>进程与程序的对应关系</h3><table>
<thead>
<tr>
<th align="center">进程</th>
<th align="center">程序</th>
</tr>
</thead>
<tbody><tr>
<td align="center">动态的</td>
<td align="center">静态的</td>
</tr>
<tr>
<td align="center">并发的</td>
<td align="center">顺序的</td>
</tr>
<tr>
<td align="center">暂时的</td>
<td align="center">永久的</td>
</tr>
</tbody></table>
<p>进程的数据结构 &#x3D; 程序 + 数据 + PCB<br>程序与进程不是一一对应的关系，一个程序可以产生多个进程。</p>
<h1 id="进程的状态及组成"><a href="#进程的状态及组成" class="headerlink" title="进程的状态及组成"></a>进程的状态及组成</h1><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><h3 id="进程的基本状态"><a href="#进程的基本状态" class="headerlink" title="进程的基本状态"></a>进程的基本状态</h3><p>进程有3种基本状态，按照分类有执行和未执行，其中执行是<strong>运行</strong>状态，未执行包括<strong>就绪</strong>和<strong>阻塞</strong>状态。</p>
<ul>
<li>运行状态：进程正在处理机上运行的状态。</li>
<li>就绪状态：已经获得了除处理机之外的所有必要的资源。当进程处于该状态时，只要获得了处理机资源，就是运行状态。</li>
<li>阻塞状态：当进程由于等待输入或输出操作，或某个同步事件而暂停运行时的状态。</li>
</ul>
<p>三种状态存在转换关系：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/操作系统/3进程与线程/4.三种进程状态转换.png" alt="三种进程状态转换" style="zoom: 50%;">

<h3 id="创建状态和退出状态"><a href="#创建状态和退出状态" class="headerlink" title="创建状态和退出状态"></a>创建状态和退出状态</h3><p>许多操作系统中，除上述三种基本状态以外，还另外添加了创建状态和退出状态。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/操作系统/3进程与线程/5.五种进程状态转换.png" alt="五种进程状态转换" style="zoom: 50%;">


<p>创建状态的进程正在创建中，不能运行。在创建过程中，要做：</p>
<ul>
<li>为进程分配PCB结构，填写相关内容</li>
<li>为进程分配进程组，连接进程的父子关系</li>
<li>为进程分配所需的资源</li>
<li>为进程建立地址空间，填写相关管理内存的操作，加载程序等</li>
</ul>
<p>退出状态或异常结束，操作系统首先要将该进程从运行状态中移出，使之成为一个不可能再次运行的进程，即使其处于退出状态，并回收资源。<br>此时系统并不会立即撤销该进程，而是暂时留在系统中，以便让其他相关进程从该退出进程的PCB中收集有关信息。此外，还需要将退出代码传递给其父进程等。</p>
<h3 id="进程的挂起"><a href="#进程的挂起" class="headerlink" title="进程的挂起"></a>进程的挂起</h3><p>在一些操作系统中，对进程的状态增加了挂起状态。<br>挂起状态指的是将该进程存放至外存，在这种状态下，即使该进程等待的事件发生或者阻塞的原因解除，该挂起进程仍然不能进入就绪状态，因为它还在外存。<br>引入挂起状态由以下几个原因：</p>
<ol>
<li>内外存对换的需要：为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存，这样进程又处于一种有别于阻塞状态的新状态。</li>
<li>用户调试程序的需要：用户在调试自己爹程序时，希望其运行的程序暂时停止下来，以便对进程的地址空间进行读写。</li>
<li>实时系统中调节负载的需要：当实时系统负载较重时，可能会影响到系统对实时任务的控制和处理，此时系统需要将不太重要或者不太紧急的进程进行挂起，以保证系统对紧急事件的及时处理。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/操作系统/3进程与线程/6.双挂起进程状态转换.png" alt="双挂起进程状态转换" style="zoom: 50%;">

<ol>
<li>阻塞-&gt;️阻塞挂起：当内存紧张时会将处于阻塞状态的进程从内存移至内存（即挂起），可以腾出更多的空间给新创建的进程或就绪的进程。</li>
<li>就绪-&gt;就绪挂起：当挂起一些阻塞进程之后仍无法满足内存的需要，或者当有高优先级阻塞的进程或低优先级就绪的进程时，系统会选择首先挂起低优先级的进程。（因为系统应当让高优先级的进程尽快完成）</li>
<li>运行-&gt;就绪挂起：在抢占式分时操作系统中，当高优先级阻塞挂起的进程因事件出现而进入就绪挂起状态时，系统可能将正在运行的进程状态转化为就绪挂起状态。</li>
<li>就绪挂起-&gt;就绪：当系统没有就绪的进程或者当就绪挂起的进程优先级高于就绪的进程时，会引起这种转改的转换。</li>
<li>阻塞挂起-&gt;阻塞：当进程时放了足够的内存空间，系统会将高优先级阻塞挂起的进程激活，移至内存当中。</li>
</ol>
<h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><p>进程是由程序、数据、进程控制快（PCB）、栈四个部分组成的。</p>
<p>进程的活动是通过CPU上执行一系列<strong>程序</strong>和对相应<strong>数据</strong>进行操作来体现的，使用<strong>进程控制块</strong>来标识进程本身的特征、进程的状态、进程的调度信息以及对资源的占有情况等，同时，程序的执行通常设计用于跟踪过程调用和过程间参数传递的<strong>堆栈</strong>。</p>
<h3 id="PCB的作用"><a href="#PCB的作用" class="headerlink" title="PCB的作用"></a>PCB的作用</h3><p>记录操作系统所需的用于描述进程情况及控制进程运行的全部信息，使一个多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位，是一个能与其他进程并发执行的进程。</p>
<ul>
<li>在操作系统需要调度某进程时，要从该进程的PCB中查找其运行状态和优先级</li>
<li>在调度某进程后，要根据PCB中所保存的处理机状态信息恢复运行的现场，并根据PCB中的程序和数据的内存地址找到该进程对应的程序和数据</li>
<li>进程执行过程中，当需要和其他相互合作的进程过实现同步、通信或文件访问时，也需要访问PCB</li>
<li>当进程因为某种原因暂停执行时，也要将其断点的处理机环境保存在PCB中</li>
</ul>
<h3 id="PCB的内容"><a href="#PCB的内容" class="headerlink" title="PCB的内容"></a>PCB的内容</h3><ol>
<li>进程描述信息<ol>
<li>进程名：由创建者提供，通常是对应可执行程序的名字。</li>
<li>进程标识符：为了方便系统使用而设置。在操作系统中，一般都为进程分配一个唯一的整数，作为进程标识符。通常是一个进程的序号。</li>
<li>用户名：创建该进程的用户名字。</li>
</ol>
</li>
<li>处理机状态信息<ol>
<li>通用寄存器：当程序运行时用于暂存信息。</li>
<li>指令计数器：存放要访问的下一条指令的地址。</li>
<li>程序状态字（PSW）寄存器：包括程序执行时的状态信息，包括条件码、执行方式、中断允许位等。</li>
<li>栈指针：每个进程都有一个或多个与之相关的地址栈，用于存放进程对应程序的过程和系统调用参数及返回地址，栈指针指向该栈的栈顶。</li>
</ol>
</li>
<li>进程调度信息<ol>
<li>进程的状态：指明该进程所处的状态。</li>
<li>进程的优先级：表示该进程的优先级程度的一个整数，优先级越高先获得处理机。</li>
<li>运行统计信息：这些信息与所采用的进程调度算法有关，其中包括进程已执行事件、等待时间等。</li>
<li>进程阻塞的原因：记录进程引起阻塞的原因。</li>
</ol>
</li>
<li>进程控制和资源占用信息<ol>
<li>程序入口地址：进程对应程序和数据的地址，当进程被调度执行时，用于找到其程序和数据。</li>
<li>程序的外存地址：进程被调出时使用的地址。当内存空间紧张时，进程可能会被调出内存，当内存有空闲空间时会被重新调入。</li>
<li>进程同步及通信机制：进程在执行时，可能会和其他进程有同步关系或相互通信，进程使用的信号量、消息队列指针等都要存放在PCB中。</li>
<li>资源占用信息：列出除CPU外，进程所需要的全部资源及已经占用的资源情况。</li>
<li>链接指针：指出本进程所在队列中下一个进程的PCB地址。</li>
</ol>
</li>
</ol>
<h3 id="进程控制块的组织"><a href="#进程控制块的组织" class="headerlink" title="进程控制块的组织"></a>进程控制块的组织</h3><p>一个系统中的进程有许多，每个进程都有一个进程控制块，因此管理好PCB，就管理好了进程。进程控制块的管理目前常用的是链接方式，即把具有相同运行状态的进程的PCB链接在一起，形成一个运行队列、就绪队列、阻塞队列、空闲队列。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/操作系统/3进程与线程/7.PCB链接队列.png" alt="PCB链接队列" style="zoom: 60%">

<p>对于单处理机系统，处于运行状态的进程只有1个，即无法组成运行队列。在多处理机系统中，运行队列以优先级高低的顺序排列。<br>对于阻塞队列，由于不同的进程阻塞原因可能不同，按照阻塞原因链接队列，例如有打印机队列、等待输入队列等。<br>空闲队列是将系统中空闲的进程控制块结构组织起来，以便新进程创建时，为之分配进程控制块。</p>
<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><p>进程控制的职能就是对系统中对全部进程实行有效的管理，其主要表现是对一个进程进行创建、撤销以及在某些进程状态之间的转换控制。</p>
<h2 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h2><h3 id="核心态和用户态"><a href="#核心态和用户态" class="headerlink" title="核心态和用户态"></a>核心态和用户态</h3><p>为了防止操作系统及其关键的数据结构（如PCB等）受到用户有意无意的破坏，通常将处理机的执行状态分为核心态和用户态。</p>
<ul>
<li>核心态：又称为系统态，具有较高的特权，能执行一切命令，访问所有寄存器和存储区。</li>
<li>用户态：具有较低特权的执行状态，只能执行规定的命令，访问指定的寄存器和存储区。</li>
</ul>
<p>通常，操作系统运行在核心态，用户程序运行在用户态。因此用户程序无法访问到操作系统的区域，防止了用户程序对操作系统的破坏。</p>
<p>程序状态字（PSW）寄存器中有一位表示处理机的执行状态。当用户程序在需要系统服务而调用系统调用时，处理机的执行状态设置为核心态；当调用完成后，处理机的执行状态又会被重置为用户态。</p>
<h3 id="内核与原语"><a href="#内核与原语" class="headerlink" title="内核与原语"></a>内核与原语</h3><p>操作系统采用层次结构，将操作系统分为若干个层次，每一层完成操作系统的一部分功能。<br>为了提高操作系统的运行效率，通常把一些与硬件紧密相关的模块放在仅靠硬件的层次上，并且常驻内存。这个部分被称为操作系统的内核。<br>内核是计算机硬件上扩充的第一层软件，操作系统需要对这部分软件进行保护。内核是使用原语实现的。<br>原语是由若干指令构成的，是用于完成一定功能的过程，但是原语是原子操作构成的，是一个不可分割的、不可中断操作。</p>
<p>在不同的操作系统中，内核的作用不尽相同，但是都包括以下三个基本功能：</p>
<ul>
<li>时钟管理：操作系统中许多活动都需要时钟。在分时系统基于时间片的进程调度中，每当时间片用完时，需要时钟管理产生终端信号，才能够重新调度进程。在实时操作系统中，截止时间的控制也需要时钟管理程序的控制。</li>
<li>中断处理：终端时操作系统赖以活动的基础，各种类型的系统调用的实现、进程调度、设备操作完成等都需要通过中断的方法通知处理机。</li>
<li>原语操作：原语操作可以完成操作系统中的一些基本功能，如进程控制、进程同步及常用的进程通信手段等。</li>
</ul>
<h3 id="进程家族树"><a href="#进程家族树" class="headerlink" title="进程家族树"></a>进程家族树</h3><p>进程控制的职责是对系统中的全部进程实行有效管理，其主要表现在对一个进程进行创建、撤销以及进程状态的转换控制。通常允许一个进程创建和控制另一个进程，前者称之为父进程，后者称之为子进程，以此类推可以得到一个进程的家族树。家族关系在PCB中有明确体现。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/操作系统/3进程与线程/8.进程家族树.png" alt="进程家族树" style="zoom: 60%">

<h2 id="进程的创建和撤销"><a href="#进程的创建和撤销" class="headerlink" title="进程的创建和撤销"></a>进程的创建和撤销</h2><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>引起创建进程的事件：</p>
<ul>
<li>用户登录：在分时操作系统中，当有用户登录后，就为该用户建立一个进程，并把它投入到就绪队列。</li>
<li>新作业进入系统：当新的作业进入系统时，操作系统需要为之分配资源并创建进程。</li>
<li>提供服务：当运行状态的用户进程提出某种请求后，系统会专门创建一个进程来提供用户所需要的服务（例如打印服务请求）。</li>
<li>应用请求：用户进程需要在自己的应用进程中创建子进程。</li>
</ul>
<p>创建原语需要做的工作：</p>
<ol>
<li>申请空白PCB。将创建者提供的有关信息填入PCB。</li>
<li>初始化进程描述信息。将进程名、进程标识符、建立父子关系、填写进程所属组、初始化处理机状态信息、初始化进程控制信息、分配初始优先级。</li>
<li>为进程分配资源、存储空间。子进程的资源可以从父进程中继承；若进程的程序不在内存中，则应将其从外存调入内存，并将有关信息填入PCB。</li>
<li>将新进程插入到就绪队列，等待调度。</li>
</ol>
<h3 id="进程的撤销"><a href="#进程的撤销" class="headerlink" title="进程的撤销"></a>进程的撤销</h3><p>引起进程撤销的事件：</p>
<ul>
<li>进程正常结束。</li>
<li>进程异常结束。</li>
<li>外界干预，由进程意外的事件引起的进程终止（例如人为干预、父进程要求、父进程撤销等）。</li>
</ul>
<p>撤销原语需要做的工作：</p>
<ol>
<li>查找撤销进程的PCB。</li>
<li>若进程处于运行状态，予以终止，并进行调度，重新挑选其他进程运行。</li>
<li>若进程有子进程，予以终止，递归处理。防止进程脱离家族而无法控制。</li>
<li>归还资源。</li>
<li>从所在队列中移出。</li>
</ol>
<h2 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h2><p>在进程执行过程中，常常会因为等待I&#x2F;O操作完成或等待某个事件出现而进入阻塞状态。当事件完成后，进程会被唤醒进入就绪状态。</p>
<h3 id="进程的阻塞与唤醒的事件"><a href="#进程的阻塞与唤醒的事件" class="headerlink" title="进程的阻塞与唤醒的事件"></a>进程的阻塞与唤醒的事件</h3><ul>
<li>请求系统服务，完成后唤醒。如请求打印机等。</li>
<li>启动某种操作，完成后唤醒。如启动某个输入设备，只有当进程完成数据的输入之后，才能继续执行。</li>
<li>新数据尚未到达，到达后唤醒。对于相互合作的进程，如果一个进程需要另一个进程的数据，而没能及时提供时，则会等待进程完成数据的提供。</li>
<li>无新工作可做，有新任务分配后唤醒。</li>
</ul>
<h3 id="阻塞原语需要做的的工作"><a href="#阻塞原语需要做的的工作" class="headerlink" title="阻塞原语需要做的的工作"></a>阻塞原语需要做的的工作</h3><ol>
<li>停止进程的执行。</li>
<li>修改PCB中进程的状态标识，将进程插入阻塞队。</li>
<li>重新调度，挑选一个就绪的进程投入运行，并进行切换。</li>
</ol>
<h3 id="唤醒原语需要做的工作"><a href="#唤醒原语需要做的工作" class="headerlink" title="唤醒原语需要做的工作"></a>唤醒原语需要做的工作</h3><ol>
<li>将进程从阻塞队列解下。</li>
<li>把进程插入就绪队列。</li>
<li>改变进程PCB中的状态。</li>
</ol>
<h2 id="进程的挂起与激活"><a href="#进程的挂起与激活" class="headerlink" title="进程的挂起与激活"></a>进程的挂起与激活</h2><h3 id="挂起原语要做的工作"><a href="#挂起原语要做的工作" class="headerlink" title="挂起原语要做的工作"></a>挂起原语要做的工作</h3><ol>
<li>检查被挂起进程的状态。</li>
<li>若处于就绪状态，将进程由就绪状态变为就绪挂起状态。</li>
<li>若处于阻塞状态，将进程由阻塞状态变为阻塞挂起状态。</li>
<li>若处于运行状态，将进程由运行状态变为就绪挂起状态，并调用进程调度程序重新调度。</li>
</ol>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><h3 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h3><p>进程是一个可以拥有资源的独立单位，进程是一个可以独立调度和分派的基本单位。<br>由于进程是资源的拥有者，因此在进程的创建、撤销和切换中系统必须为之付出较大的时间、空间开销。所以系统中所设置的进程的数目不宜过多，进程切换的频率不宜过高。这就限制了进程并发程度的提高。</p>
<p>为了提高系统并发执行的程度，进一步提高系统的吞吐量，在20世纪80年代提出了线程的概念。<br>通过引入线程实现多线程，可以具有以下优点：</p>
<ul>
<li>响应度高：在交互式程序中，部分线程可以阻塞或执行较冗长的操作，另一部分线程继续执行，保证用户的响应时间</li>
<li>资源共享：同一个进程的多个线程共享进程拥有的内存和资源</li>
<li>经济：线程的创建和切换比进程更为经济</li>
</ul>
<p>线程是进程的一个实体，是被独立调度和分派的基本单位，表示进程中的一个控制点，执行一系列指令。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/操作系统/3进程与线程/9.进程线程关系.png" alt="进程线程关系" style="zoom: 60%">

<h3 id="线程的组成"><a href="#线程的组成" class="headerlink" title="线程的组成"></a>线程的组成</h3><p>线程有时会被称为轻型进程(Light Weight Process, LWP)，每个线程都有自己的线程控制块(Thread Control Block, TCB)。</p>
<p>TCB主要包括：</p>
<ul>
<li>线程标识符。</li>
<li>描述处理机状态信息的一组寄存器。包括通用寄存器、指令计数器、程序状态字等。</li>
<li>栈指针。每个线程都有用户栈和核心栈两个栈。当在用户态下运行时使用用户栈、在核心态下运行使用核心栈。</li>
<li>一个私有的存储区。用于存放现场保护信息和其他与该线程相关的统计信息。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/操作系统/3进程与线程/10.进程和线程的比较.png" alt="进程和线程的比较" style="zoom: 60%">

<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>线程是一个动态过程，在一定条件下可以转换自己的状态。<br>通常，创建一个进程时，其主线程也会被创建，其他线程由主线程创建，，并提供对占空间，将新线程投入就绪队列。</p>
<p>当CPU空闲时，线程调度程序会从就绪队列中选择</p>
<p>操作系统上一篇：<a href="/p/20220513/" target="_blank">操作系统概述</a><br>操作系统下一篇：进程同步与通信</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B/">进程</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/20220613/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E5%85%B6%E4%BB%96/heartbeat/1cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">rPPG —— 非接触式心率测量程序</div></div></a></div><div class="next-post pull-right"><a href="/p/20220605/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E5%B7%A5%E5%85%B7/mac/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Mac(m1)奇葩问题解决</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zhinushannan</div><div class="author-info__description">梦想将故</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zhinushannan/"><i class="fab fa-github"></i><span>Follow me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zhinushannan" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zhinushannan@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">1.</span> <span class="toc-text">进程的引入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text">进程与程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%81%93%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">1.2.</span> <span class="toc-text">单道程序的顺序执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">1.2.1.</span> <span class="toc-text">程序的顺序执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.2.</span> <span class="toc-text">顺序执行的特征</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C"><span class="toc-number">1.3.</span> <span class="toc-text">多道程序的并发执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C"><span class="toc-number">1.3.1.</span> <span class="toc-text">程序的并发执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E7%9A%84%E6%9D%A1%E4%BB%B6-%E2%80%94%E2%80%94-Bernstein"><span class="toc-number">1.3.2.</span> <span class="toc-text">并发执行的条件 —— Bernstein</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.3.3.</span> <span class="toc-text">程序并发执行的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.4.</span> <span class="toc-text">进程与程序的对应关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%8A%E7%BB%84%E6%88%90"><span class="toc-number">2.</span> <span class="toc-text">进程的状态及组成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.</span> <span class="toc-text">进程的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">进程的基本状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%8A%B6%E6%80%81%E5%92%8C%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">创建状态和退出状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7"><span class="toc-number">2.1.3.</span> <span class="toc-text">进程的挂起</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">2.2.</span> <span class="toc-text">进程控制块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">2.2.1.</span> <span class="toc-text">进程的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCB%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">PCB的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCB%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">2.2.3.</span> <span class="toc-text">PCB的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">2.2.4.</span> <span class="toc-text">进程控制块的组织</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8"><span class="toc-number">3.1.</span> <span class="toc-text">操作系统内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81"><span class="toc-number">3.1.1.</span> <span class="toc-text">核心态和用户态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E4%B8%8E%E5%8E%9F%E8%AF%AD"><span class="toc-number">3.1.2.</span> <span class="toc-text">内核与原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%AE%B6%E6%97%8F%E6%A0%91"><span class="toc-number">3.1.3.</span> <span class="toc-text">进程家族树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%92%A4%E9%94%80"><span class="toc-number">3.2.</span> <span class="toc-text">进程的创建和撤销</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">3.2.1.</span> <span class="toc-text">进程的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%92%A4%E9%94%80"><span class="toc-number">3.2.2.</span> <span class="toc-text">进程的撤销</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E5%92%8C%E5%94%A4%E9%86%92"><span class="toc-number">3.3.</span> <span class="toc-text">进程的阻塞和唤醒</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.3.1.</span> <span class="toc-text">进程的阻塞与唤醒的事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%8E%9F%E8%AF%AD%E9%9C%80%E8%A6%81%E5%81%9A%E7%9A%84%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="toc-number">3.3.2.</span> <span class="toc-text">阻塞原语需要做的的工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%A4%E9%86%92%E5%8E%9F%E8%AF%AD%E9%9C%80%E8%A6%81%E5%81%9A%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="toc-number">3.3.3.</span> <span class="toc-text">唤醒原语需要做的工作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7%E4%B8%8E%E6%BF%80%E6%B4%BB"><span class="toc-number">3.4.</span> <span class="toc-text">进程的挂起与激活</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E5%8E%9F%E8%AF%AD%E8%A6%81%E5%81%9A%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="toc-number">3.4.1.</span> <span class="toc-text">挂起原语要做的工作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">线程的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">4.1.1.</span> <span class="toc-text">线程的引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">4.1.2.</span> <span class="toc-text">线程的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.1.3.</span> <span class="toc-text">线程的状态</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/20220613/" title="rPPG —— 非接触式心率测量程序"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E5%85%B6%E4%BB%96/heartbeat/1cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="rPPG —— 非接触式心率测量程序"/></a><div class="content"><a class="title" href="/p/20220613/" title="rPPG —— 非接触式心率测量程序">rPPG —— 非接触式心率测量程序</a><time datetime="2022-06-13T00:29:07.000Z" title="发表于 2022-06-13 08:29:07">2022-06-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/20220609/" title="进程与线程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1.cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="进程与线程"/></a><div class="content"><a class="title" href="/p/20220609/" title="进程与线程">进程与线程</a><time datetime="2022-06-09T00:29:07.000Z" title="发表于 2022-06-09 08:29:07">2022-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/20220605/" title="Mac(m1)奇葩问题解决"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E5%B7%A5%E5%85%B7/mac/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mac(m1)奇葩问题解决"/></a><div class="content"><a class="title" href="/p/20220605/" title="Mac(m1)奇葩问题解决">Mac(m1)奇葩问题解决</a><time datetime="2022-06-05T00:29:07.000Z" title="发表于 2022-06-05 08:29:07">2022-06-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By zhinushannan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://jsdelivr.kwcoder.club/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://jsdelivr.kwcoder.club/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://jsdelivr.kwcoder.club/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://jsdelivr.kwcoder.club/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? '' : ''

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://jsdelivr.kwcoder.club/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>new CaveDraw({
  ele: '#veditor',
  special: 'valine',
  openBtn: {
    style: 'background-color:#b37ba4;color:white;',
    hoverStyle: 'background-color: #49d0c0;'
  },
  canvasStyle: 'cursor:crosshair;background:whitesmoke;/*margin-bottom:5px;border-radius:0px;*/'
})

var valine = new Valine();
valine.init({
  el: '#vcomment',
  appId: '1sAcEuvKSBgfYxRJpXU3QMKE-MdYXbMMI',
  appKey: 'WVHuElCrdb2Tquwe9OFjFExP',
  avatar: 'monsterid',
  serverURLs: 'https://1saceuvk.api.lncldglobal.com',
  emojiMaps: "",
  path: window.location.pathname,
  visitor: false
});</script></div><script defer="defer" id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/js/third-party/canvas-nest.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"log":false});</script></body></html>