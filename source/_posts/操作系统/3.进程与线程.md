---
title: 进程与线程
urlname: 20220609
date: 2022-06-09 08:29:07
tags: [操作系统, 进程, 线程]
categories: [操作系统]
keywords: [操作系统, 进程, 线程]
top_img: /images/java/多线程/1.cover.png
cover: /images/java/多线程/1.cover.png
---

# 进程的引入
## 进程与程序
进程是**可并发执行的程序**在一个**数据集合**上的执行过程。

程序是一个按顺序设计的计算机指令的集合，而进程就是执行这个指令集合的过程。**程序是一个存放在计算机存储空间内的静态文件**。

## 单道程序的顺序执行

### 程序的顺序执行

<img src="/images/操作系统/3进程与线程/1.顺序执行时操作的先后次序.png" style="zoom: 50%;">

顺序执行中，每个程序的执行顺序是严格按照次序先后关系进行的。例如：

![程序段的执行.png](/images/操作系统/3进程与线程/2.程序段的执行.png)

在单道环境中，程序段的执行也是严格按照顺序执行的。


### 顺序执行的特征

1. 顺序性：程序在执行时，严格按照规定的顺序执行。
2. 封闭性：程序是在封闭的环境中执行的，程序在执行时独占系统中的全部资源。
3. 可再现性：当程序被重复执行时，只要初始条件相同，其执行结果必然相同。

应用：这些特征给测试和修改程序带来了很大的方便（debug）。

## 多道程序的并发执行

单道程序系统浪费资源、效率低下，现代操作系统几乎不采用，而广泛采用多道程序设计技术。多道程序设计是在内存中存放多道程序，他们在操作系统的控制下在CPU上交替执行。

### 程序的并发执行
为了提高计算机内各种资源的利用率，提高计算机系统的处理能力，并发处理技术得到广泛的应用。
而有些计算是允许并发执行的，有些操作是需要顺序执行的。
例如，下面两张图中，第一张图的计算是必须按照顺序执行的，而第二张图可以并发执行：
![程序段的执行.png](/images/操作系统/3进程与线程/2.程序段的执行.png)
![并发执行的程序段.png](/images/操作系统/3进程与线程/3.并发执行的程序段.png)

### 并发执行的条件 —— Bernstein

对于两个进程P1、P2，记P1的读集、写集分别为R(P1)、W(P1)，P2的读集、写集为R(P2)、R(P2)，若满足：`R(P1)∩W(P2)∪R(P2)∩W(P1)∪W(P1)∩W(P2)={}`，则P1、P2可以并发执行且具有再现性。

范例:
对于：
P1：    a=5
P2：    b=6
P3：    c=a+b
P4：    d=c+1

的执行图如下：

{% mermaid %}
graph LR
P1 --> P3
p2 --> P3
P3 --> P4
{% endmermaid %}

> P1:  a=5
> P2:	  b=6
> R(P1)={} W(P1)={a}
> R(P2)={} W(P2)={b}
> R(P1) ∩W(P2)={} R(P2) ∩W(P1)={}
> W(P1) ∩W(P2)={}
> R(P1)∩W(P2)∪R(P2)∩W(P1)∪W(P1)∩W(P2)={}
> P1、P2可以并发执行

> P3:	c=a+b
> P4:		d=c+1
> R(P3)={a,b} W(P3)={c}
> R(P4)={c} W(P4)={d}
> R(P3) ∩ W(P4)={}
> R(P4) ∩ W(P3)={c}
> R(P3) ∩ W(P4) ∪ R(P4) ∩ W(P3) ∪ W(P3) ∩ W(P4) ={c}
> P3、P4不能并发执行

### 程序并发执行的特征
1. 间断性：进程之间需要相互配合，有时需要暂停等待另一个进程执行完毕才可以继续执行。
2. 失去封闭性：多个程序共享系统的各种资源，这些资源的状态由多个程序改变，致使其失去封闭性。
3. 失去可再现性：由于失去了封闭性，系统的资源状态的变化是不可预测的，因而也失去了可再现性。

### 进程与程序的对应关系

| 进程 | 程序 |
| :--: | :--: |
| 动态的 | 静态的 |
| 并发的 | 顺序的 |
| 暂时的 | 永久的 |

数据结构 = 程序 + 数据 + PCB
程序与进程不是一一对应的关系，一个程序可以产生多个进程。

# 进程的状态及组成

## 进程的状态
### 进程的基本状态
进程有3种基本状态，按照分类有执行和未执行，其中执行是**运行**状态，未执行包括**就绪**和**阻塞**状态。

- 运行状态：进程正在处理机上运行的状态。
- 就绪状态：已经获得了除处理机之外的所有必要的资源。当进程处于该状态时，只要获得了处理机资源，就是运行状态。
- 阻塞状态：当进程由于等待输入或输出操作，或某个同步事件而暂停运行时的状态。

三种状态存在转换关系：

<img src="/images/操作系统/3进程与线程/4.三种进程状态转换.png" alt="三种进程状态转换" style="zoom: 50%;">

### 创建状态和退出状态

许多操作系统中，除上述三种基本状态以外，还另外添加了创建状态和退出状态。

<img src="/images/操作系统/3进程与线程/5.五种进程状态转换.png" alt="五种进程状态转换" style="zoom: 50%;">


创建状态的进程正在创建中，不能运行。在创建过程中，要做：
- 为进程分配PCB结构，填写相关内容
- 为进程分配进程组，连接进程的父子关系
- 为进程分配所需的资源
- 为进程建立地址空间，填写相关管理内存的操作，加载程序等

退出状态或异常结束，操作系统首先要将该进程从运行状态中移出，使之成为一个不可能再次运行的进程，即使其处于退出状态，并回收资源。
此时系统并不会立即撤销该进程，而是暂时留在系统中，以便让其他相关进程从该退出进程的PCB中收集有关信息。此外，还需要将退出代码传递给其父进程等。

## 进程的挂起
在一些操作系统中，对进程的状态增加了挂起状态。
挂起状态指的是将该进程存放至外存，在这种状态下，即使该进程等待的事件发生或者阻塞的原因解除，该挂起进程仍然不能进入就绪状态，因为它还在外存。
引入挂起状态由以下几个原因：
1. 内外存对换的需要：为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存，这样进程又处于一种有别于阻塞状态的新状态。
2. 用户调试程序的需要：用户在调试自己爹程序时，希望其运行的程序暂时停止下来，以便对进程的地址空间进行读写。
3. 实时系统中调节负载的需要：当实时系统负载较重时，可能会影响到系统对实时任务的控制和处理，此时系统需要将不太重要或者不太紧急的进程进行挂起，以保证系统对紧急事件的及时处理。

<img src="/images/操作系统/3进程与线程/6.双挂起进程状态转换.png" alt="双挂起进程状态转换" style="zoom: 50%;">

1. 阻塞->️阻塞挂起：当内存紧张时会将处于阻塞状态的进程从内存移至内存（即挂起），可以腾出更多的空间给新创建的进程或就绪的进程。
2. 就绪->就绪挂起：当挂起一些阻塞进程之后仍无法满足内存的需要，或者当有高优先级阻塞的进程或低优先级就绪的进程时，系统会选择首先挂起低优先级的进程。（因为系统应当让高优先级的进程尽快完成）
3. 运行->就绪挂起：在抢占式分时操作系统中，当高优先级阻塞挂起的进程因事件出现而进入就绪挂起状态时，系统可能将正在运行的进程状态转化为就绪挂起状态。
4. 就绪挂起->就绪：当系统没有就绪的进程或者当就绪挂起的进程优先级高于就绪的进程时，会引起这种转改的转换。
5. 阻塞挂起->阻塞：当进程时放了足够的内存空间，系统会将高优先级阻塞挂起的进程激活，移至内存当中。

# 进程控制
# 线程

