---
title: 进程同步与通信
urlname: 20220620
date: 2022-06-20 08:29:07
tags: [操作系统, 进程, 通信, 同步]
categories: [操作系统]
keywords: [操作系统, 进程, 通信, 同步]
top_img: /images/java/多线程/1.cover.png
cover: /images/java/多线程/1.cover.png
hidden: true
---


操作系统上一篇：<a href="/p/20220609/" target="_blank">进程与线程</a>
操作系统下一篇：调度与死锁

# 进程同步与互斥
## 并发原理
### 并发带来的问题
在多道程序环境中，为了提高处理机的利用率，使用了并发设计。从宏观上看，并发是同时运行，从微观上看，并发是程序之间的交替执行。
由于程序的并发是不可预测的，它取决于其他进程的活动、操作系统的调度策略等，这就引发了以下困难：
- 全局变量的共享充满危险。如果多个进程共享一个变量并且都进行读写，那么不同的读写执行顺序是非常关键的。
- 难以最佳管理资源的分配。如果某进程请求使用I/O设备并且得到设备，但是该进程在使用设备前被挂起，操作系统就需要把该设备锁定，不能分配给其他进程，因为操作系统不知道该进程什么时候会被再次执行。此外，资源分配还会导致死锁的风险。
- 难以定位程序的错误。因为并发执行的程序存在不确定性和不可再现性。

针对如上问题，操作系统需要关注：
- 记录每个进程的情况，并通过PCB实现。
- 为每个进程分配和释放各种资源。
- 保护每个进程的数据和资源，避免遭到其他进程的干涉和破坏。
- 保证进程执行结果的正确性，进程的执行结果和速度无关。

### 进程的交互
**按进程之间是否知道对方的存在以及进程的交互方式划分**，进程的交互可以分为以下三种情况：
- 进程之间不知道对方的存在。这是一些独立的进程，不会一起工作。但是操作系统也需要对它们进行管理，例如两个无关的进程需要使用同一打印机。
- 进程间接知道对方。进程之间通过共享数据进行合作。
- 进程直接得知对方。通过进程标识符互相通信，合作完成某些任务。

| 知道程度 | 关系 | 对其他进程的影响 | 潜在的控制问题 |
| :--: | :--: | :--: | :--: |
| 进程间不知道对方 | 竞争 | 进程的执行结果与其他进程无关 | 互斥、死锁、饿死 |
| 进程间接知道对方 | 共享合作 | 进程的执行结果可能依赖于从其他进程中得到的消息 | 互斥、死锁、饿死、数据一致性 |
| 进程直接知道对方 | 通信合作 | 进程的执行结果可能依赖于从其他进程中得到的消息 | 死锁、饿死 |


**按进程之间交互方式划分**，可以分为互斥、同步和通信：
- 互斥：由于共享资源所要求的排他性，多个进程不能同时使用同一个资源。这种情况下，进程之间知道对方的程度最低。
- 同步：多个进程中发生的事件存在某种时序关系，必须协同动作、相互配合。主要任务是使并发执行的进程有效的共享资源和相互合作，从而使程序的执行具有可在现性。这种情况下，进程之间知道对方的程度较高，因为进程间需要合作。
- 通信：指多进程之间要传递一定的信息。在这种情况下，进程之间知道对方的程度最高，需要传递的信息量也最大。


### 进程互斥

当两个或以上进程竞争同一资源时，一个进程占用，其他进程必须等待，产生相互制约的关系，即互斥关系。

### 进程同步

多个进程中发生的事件存在着某种时序关系，必须按照规定的时许执行，以共同完成一项任务。

## 临界资源与临界区
### 临界区与临界资源的概念

在计算机中，有些资源允许多个进程同时访问；有些不能，如果多个进程访问这类资源，会引起竞争。操作系统需要保护这些资源，以防止两个或两个以上的进程同时访问。
不允许多个进程同时访问的资源被称为`临界资源`，进程中访问临界资源的那段程序被称为`临界区`。
几个进程共享同一临界资源，就必须以相互排斥的方式，即当一个进程正在访问时，其他进程必须等待。

以P1、P2两个进程为例，假设COUNT初始值为5：
```text
P1:
{
    R1 = COUNT;
    R1 = R1 + 1;
    COUNT = R1;
}
```
```text
P2:
{
    R2 = COUNT;
    R2 = R2 + 1;
    COUNT = R2;
}
```
若P1、P2以互斥的方式执行，当P1执行完成后，COUNT为6，当P2执行完成后，COUNT为7。
若交替执行，执行效果如下：
```text
COUNT = 5;
R1 = COUNT;  // 5
R2 = COUNT;  // 5
R1 = COUNT + 1;  // 6
R2 = COUNT + 1;  // 6
COUNT = R1;  // 6
COUNT = R2;  // 6
```
最终COUNT的值为6。

### 进程访问临界区的一般结构

如果能够实现进程互斥的进入临界区，就可以实现对临界资源的互斥访问。为此，可以在每个进程进入临界区之前对要访问的临界资源进行检查，看它是否正在被访问。因此，在临界区前需要增加一段用于进行上述检查的代码，这段代码称为`进入区`。

当进程退出临界区后，需要将临界区的状态标志恢复为未被访问的标志，这段代码被称为`退出区`。

进程中除了进入区、临界区和退出区之外的部分被称为剩余区。

![进程访问临界区的一般结构](/images/操作系统/4进程同步与通信/2进程访问临界区的一般结构.png)


### 进程区进入准则
- 空闲让进。当没有进程处于临界区时，临界资源处于空闲状态，允许进程进入临界区。
- 忙则等待。当已有进程进入临界区时，临界资源正在访问，其他想进入临界区的进程必须等待。
- 有限等待。对于要求访问临界资源的进程，应保证在有效的时间内进入，以免进入"死等"的状态。
- 让权等待。当进程不能进入临界区时，应立即释放处理机，以免其他进程进入"忙等"的状态。


## 互斥实现的硬件方法
### 禁止中断

在单处理机多道程序环境中，并发执行的程序在CPU上交替执行。对于一个进程而言，它一直在运行，直到被中断。
因此，为了保证互斥，只要保证一个进程不被中断即可，可以通过系统内核开启、禁止中断实现。

![用禁止中断的方法访问临界区](/images/操作系统/4进程同步与通信/3用禁止中断的方法访问临界区.png)

但是通过禁止中断的方法访问临界区的代价很高，进程被限制只能交替执行。同时，在多处理机环境中，禁止中断仅对本指令的CPU起作用，对其他CPU不起作用，即无法保证对临界区的互斥进入。

### 专用机器指令

在很多计算机，尤其是多处理机的操作系统中，通常设专用指令来解决互斥问题。依据指令的不通，硬件方法分为TS指令和Swap指令。

#### TS指令

对临界资源设置一个布尔变量lock，用于标识资源的状态，true为被占用，false为空闲。
在进入区对lock进行检查和修改，当有进程在临界区时，循环检查，直到进程退出。

TS函数伪代码：
```text
bool TS(bool lock) {
    bool old = lock;
    lock = true;
    return old;
}
```
上锁和检查是两个步骤，不具有原子性。TS指令通过返回保存上锁时的lock值的old临时变量，可以保证在多线程并发执行的时候不会存在线程安全问题。

![用TS指令访问临界区](/images/操作系统/4进程同步与通信/4用TS指令访问临界区.png)

#### Swap指令

为临界资源设置全局布尔变量lock，初始值为false，为每个进程设置一个全局布尔变量key。
在进入区利用Swap指令交换lock和key的内容，然后检查key的状态。当有进程在临界区时，循环交换和检查，直到其他进程退出。

Swap指令伪代码：
```text
void Swap(bool lock, bool key) {
    bool temp;
    temp = lock;
    lock = key;
    key = temp;
}
```

![用Swap指令访问临界区](/images/操作系统/4进程同步与通信/5用Swap指令访问临界区.png)

### 硬件方法的优缺点
#### 优点
- 适用范围广。适用于任意数目的进程，单处理机、多处理机都能使用。
- 简单。硬件方法的标志简单，容易验证其正确性。
- 支持多个临界区。一个进程中有多个临界区时，只需为每个临界区设置一个布尔变量即可。

#### 缺点
- 进程在等待进入临界区时，无法做到"让权等待"。
- 进入临界区的进程是从等待进程中随机选取的，可能造成某个进程长时间不能被选上，导致"饥饿"现象。


## 互斥实现的软件方法
### 算法1：单标志算法

假设两个进程P0、P1互斥进入临界区，设置公共变量turn，用于指示进入临界区的进程标识。
进程在进入区通过循环检查变量turn确定是否可以进入，即当turn为0时，P0可以进入，否则循环检查，直到turn变为0为止。P0进入退出区时，将turn改成另一个进程的标识，即turn=1。
从而实现P0、P1轮流访问临界资源。

![单标志算法](/images/操作系统/4进程同步与通信/6单标志算法.png)

该算法保证任何时刻之多只有一个进程进入临界区，但缺点是强制性轮流进入临界区，不能保证"空闲让进"。

### 算法2：双标志、先检查算法

为了克服算法1强制性轮流进入临界区的缺点，设置标志数组flag[2]。初识时每个元素为false，标识所有进程都未进入临界区。若flag[0]=true，则表示进程P0进入临界区。
每个进程进入临界区时，先查看临界资源是否被使用，若正在使用，则进程等待，否则进入，实现了"空闲让进"。

![双标志、先检查算法](/images/操作系统/4进程同步与通信/7双标志、先检查算法.png)

该算法解决了"空闲让进"问题，但如果P0和P1同时要求进入临界区，此时会发现对方的访问标志都为false，于是两个进程都进入了临界区，所以该算法存在可能同时让两个进程进入临界区的缺点，不能保证"忙则等待"。

### 算法3：双标志、先修改后检查算法

为了解决算法2的问题，可以在检查前对flag进行修改，此时的flag的含义为谁想进入临界区。

![双标志、先修改后检查算法](/images/操作系统/4进程同步与通信/8双标志、先修改后检查算法.png)

但该算法可能会因为两个进程过分"谦让"导致谁都进不了临界区。

### 算法4：先修改、后检查、后修改者等待算法

结合算法1和算法3，标志flag[0]为true表示进程P0想进入临界区，标志turn表示要在进入区等待的进程标识。
在进入区先修改后检查，通过修改同一标志turn来描述标志修改的先后；检查对方标志flag，如果对方不想进入，自己再进入。
如果对方想进入，则检查标志turn，由于turn中保存的是较晚的一次赋值，因此较晚修改标志的进程等待，较早修改标志的进程进入临界区。

![先修改、后检查、后修改者等待算法](/images/操作系统/4进程同步与通信/9先修改、后检查、后修改者等待算法.png)

算法4实现了同步机制中的前两条——"空闲让进"和"忙则等待"。
但从如上方法可以发现，对于3个以上的进程互斥又要区别对待，因此用软件方法解决进程互斥问题有一定难度，也有很大的局限性，因此现在很少有人用这样的方法。

## 信号量和PV操作

1965年，荷兰学者Dijkstra提出信号量机制，后期得到广泛应用。

### 信号量的定义

最初定义的信号量包括一个整形值s和一个等待队列s.queue，信号量只能通过两个原语P、V操作来访问。

信号量：
```c
struct semaphore {
    int value;
    struct PCB *queue;
}
```

P原语：
```c
void wait(semaphore s) {
    s.value = s.value - 1;
    if (s.value < 0) {
        // 将进程阻塞，并将其投入等待队列s.ququq
        block(s.queue);
    }
}
```

V原语：
```c
void signal(semaphore s) {
    s.value = s.value + 1;
    if (s.value <= 0) {
        // 唤醒阻塞进程，将其从等待队列s.queue取出，投入就绪队列
        wackup(s.queue);
    }
}
```

### 信号量的物理意义

1. 信号量的初值s.value表示系统中某资源的数目，因而又称为资源信号量。
2. P操作：进程请求一个资源。需要对资源数目减1，当s.value<0时，表示资源已经分配完毕，资源不足，进程无法继续执行，进程执行block(s.queue)自我阻塞，放弃处理机，并插入等待该信号量的等待队列。
3. V操作：进程释放一个资源。需要对资源数目加1，当s.value<=0时，表示该信号量的等待队列中有等待该资源的进程被阻塞，故应该调用wakeup(s.queue)原语唤醒进程。
4. 当s.value<0时，|s.value|表示等待队列的进程数。

### 用信号量解决互斥问题

如果信号量的初值为1，表示仅允许一个进程访问临界区，此时的信号量转换为互斥信号量。P操作和V操作分别置于进入区和退出区。

![用信号量解决互斥问题](/images/操作系统/4进程同步与通信/10用信号量解决互斥问题.png)

### 用信号量解决同步问题

用信号量可以解决同步问题，即控制进程执行的先后顺序。
如果有两个进程P1、P2，要求P2必须在P1之后执行。则只需设置一个信号量S，其初值为0，将V(S)操作放在进程P1的代码段C1后面，将P(S)操作放在进程P2的代码段C2前面：
![信号量实现同步1](/images/操作系统/4进程同步与通信/11信号量实现同步1.png)

对于如下进程关系：
{% mermaid %}
graph LR
P1 --> P2 --> P4
P1 --> P3
{% endmermaid %}

可以通过如下代码实现：
![信号量实现同步2](/images/操作系统/4进程同步与通信/12信号量实现同步2.png)


操作系统上一篇：<a href="/p/20220609/" target="_blank">进程与线程</a>
操作系统下一篇：调度与死锁
